<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CID OCR (Auto Rotate + Deskew + OCR)</title>
  <script src="public/js/opencv.js"></script>
  <script src="public/js/tesseract.min.js"></script>
</head>
<body>
<h3>‡∏≠‡πà‡∏≤‡∏ô‡πÄ‡∏•‡∏Ç‡∏ö‡∏±‡∏ï‡∏£‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏ä‡∏ô (‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏†‡∏≤‡∏û‡∏ó‡∏∏‡∏Å‡πÅ‡∏ô‡∏ß)</h3>
<input type="file" id="fileInput" accept="image/*">
<pre id="output"></pre>
<canvas id="cvCanvas" style="display:none;"></canvas>

<script>
const fileInput = document.getElementById('fileInput');
const canvas = document.getElementById('cvCanvas');
const ctx = canvas.getContext('2d');
const output = document.getElementById('output');

// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö checksum 13 ‡∏´‡∏•‡∏±‡∏Å
function validateThaiID(id){
  if(!/^\d{13}$/.test(id)) return false;
  const d=id.split('').map(Number);
  let s=0;for(let i=0;i<12;i++)s+=d[i]*(13-i);
  return (11-(s%11))%10===d[12];
}

// üîÑ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏°‡∏∏‡∏ô‡∏†‡∏≤‡∏û‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô (0¬∞)
function autoRotateToLandscape(src){
  // ‡πÉ‡∏ä‡πâ‡∏Ç‡∏ô‡∏≤‡∏î‡∏†‡∏≤‡∏û‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡∏ö‡πà‡∏á‡∏ä‡∏µ‡πâ‡∏Å‡πà‡∏≠‡∏ô (‡∏ñ‡πâ‡∏≤‡∏Å‡∏ß‡πâ‡∏≤‡∏á < ‡∏™‡∏π‡∏á ‡πÅ‡∏™‡∏î‡∏á‡∏ß‡πà‡∏≤‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á)
  if(src.cols < src.rows){
    let dst = new cv.Mat();
    cv.rotate(src, dst, cv.ROTATE_90_CLOCKWISE);
    console.log("Rotate 90¬∞ CW (portrait ‚Üí landscape)");
    return dst;
  }

  // ‡∏´‡∏≤ contour ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏•‡∏±‡∏Å‡∏©‡∏ì‡∏∞‡∏Ñ‡∏•‡πâ‡∏≤‡∏¢‡∏Ç‡∏≠‡∏ö‡∏ö‡∏±‡∏ï‡∏£‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏ß‡πà‡∏≤ ‡∏Å‡∏•‡∏±‡∏ö‡∏´‡∏±‡∏ß‡πÑ‡∏´‡∏°
  let gray = new cv.Mat();
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
  cv.GaussianBlur(gray, gray, new cv.Size(5,5), 0);
  let edges = new cv.Mat();
  cv.Canny(gray, edges, 50, 150);
  let contours = new cv.MatVector();
  let hierarchy = new cv.Mat();
  cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  // ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å contour ‡πÉ‡∏´‡∏ç‡πà‡∏™‡∏∏‡∏î‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÅ‡∏ó‡∏ô‡∏ö‡∏±‡∏ï‡∏£
  let maxArea = 0;
  let maxRect = null;
  for(let i=0; i<contours.size(); i++){
    let cnt = contours.get(i);
    let rect = cv.boundingRect(cnt);
    let area = rect.width * rect.height;
    if(area > maxArea){ maxArea = area; maxRect = rect; }
    cnt.delete();
  }

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏ß‡πà‡∏≤‡∏Ç‡∏≠‡∏ö‡∏ö‡∏±‡∏ï‡∏£‡∏≠‡∏¢‡∏π‡πà‡∏•‡πà‡∏≤‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏ö‡∏ô (‡πÄ‡∏ä‡πà‡∏ô‡∏Å‡∏•‡∏±‡∏ö‡∏´‡∏±‡∏ß)
  if(maxRect && maxRect.y > src.rows/2){
    let dst = new cv.Mat();
    cv.rotate(src, dst, cv.ROTATE_180);
    console.log("Rotate 180¬∞ (upside-down)");
    gray.delete(); edges.delete(); contours.delete(); hierarchy.delete();
    return dst;
  }

  gray.delete(); edges.delete(); contours.delete(); hierarchy.delete();
  return src.clone();
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏°‡∏∏‡∏°‡πÅ‡∏•‡∏∞‡πÅ‡∏Å‡πâ‡πÄ‡∏≠‡∏µ‡∏¢‡∏á
function autoDeskew(srcGray){
  let bw=new cv.Mat();
  cv.threshold(srcGray,bw,0,255,cv.THRESH_BINARY+cv.THRESH_OTSU);

  let contours=new cv.MatVector(),hier=new cv.Mat();
  cv.findContours(bw,contours,hier,cv.RETR_LIST,cv.CHAIN_APPROX_SIMPLE);

  let pts=[];
  for(let i=0;i<contours.size();i++){
    const c=contours.get(i);
    for(let j=0;j<c.data32S.length/2;j++){
      pts.push(new cv.Point(c.data32S[j*2],c.data32S[j*2+1]));
    }
    c.delete();
  }

  if(pts.length===0){
    bw.delete();contours.delete();hier.delete();
    return {mat:srcGray.clone(), angle:0};
  }

  const mat=cv.matFromArray(pts.length,1,cv.CV_32SC2,pts.flatMap(p=>[p.x,p.y]));
  const rect=cv.minAreaRect(mat);
  let angle=rect.angle;
  if(angle < -45) angle += 90;
  const absAngle=Math.abs(angle);
  const aspect = srcGray.cols / srcGray.rows;

  if ((absAngle > 80 && absAngle < 100) && aspect > 1.2) {
    console.log("Skip false 90¬∞ rotation for landscape image");
    bw.delete();contours.delete();hier.delete();mat.delete();
    return {mat:srcGray.clone(), angle:0};
  }

  if(absAngle < 1.5){
    bw.delete();contours.delete();hier.delete();mat.delete();
    return {mat:srcGray.clone(), angle:0};
  }

  const center=new cv.Point(srcGray.cols/2,srcGray.rows/2);
  const M=cv.getRotationMatrix2D(center,angle,1);
  let dst=new cv.Mat();
  cv.warpAffine(srcGray,dst,M,new cv.Size(srcGray.cols,srcGray.rows),
                cv.INTER_LINEAR,cv.BORDER_REPLICATE);

  bw.delete();contours.delete();hier.delete();mat.delete();M.delete();
  return {mat:dst, angle:angle};
}

fileInput.addEventListener('change',async e=>{
  output.textContent='‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏≠‡πà‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏†‡∏≤‡∏û ‡πÇ‡∏õ‡∏£‡∏î‡∏£‡∏≠...';
  const f=e.target.files[0]; if(!f) return;
  const img=new Image(); img.src=URL.createObjectURL(f);
  img.onload=async()=>{
    canvas.width=img.width; canvas.height=img.height;
    ctx.drawImage(img,0,0);

    let src=cv.imread(canvas);

    // ‚úÖ ‡∏´‡∏°‡∏∏‡∏ô‡∏†‡∏≤‡∏û‡πÉ‡∏´‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô‡∏Å‡πà‡∏≠‡∏ô
    let rotated = autoRotateToLandscape(src);

    // ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô grayscale
    let gray=new cv.Mat();
    cv.cvtColor(rotated,gray,cv.COLOR_RGBA2GRAY,0);

    // ‡∏•‡∏î noise ‡∏Å‡πà‡∏≠‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏°‡∏∏‡∏°
    cv.GaussianBlur(gray,gray,new cv.Size(3,3),0);

    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏°‡∏∏‡∏°‡πÄ‡∏≠‡∏µ‡∏¢‡∏á‡πÅ‡∏•‡∏∞‡πÅ‡∏Å‡πâ‡∏ñ‡πâ‡∏≤‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
    const {mat:deskewed, angle}=autoDeskew(gray);
    console.log('Detected angle:', angle.toFixed(2));

    // ‚úÖ ‡πÉ‡∏ä‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏™‡πà‡∏ß‡∏ô‡∏ö‡∏ô‡∏Ç‡∏≠‡∏á‡∏†‡∏≤‡∏û
    const TOP_RATIO=0.65;
    const h=Math.floor(deskewed.rows*TOP_RATIO);
    const roi=new cv.Rect(0,0,deskewed.cols,h);
    let top=deskewed.roi(roi);

    // ‚úÖ Threshold + morphology
    let bin=new cv.Mat();
    cv.adaptiveThreshold(top,bin,255,
      cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY,41,10);
    let kernel=cv.Mat.ones(2,2,cv.CV_8U);
    cv.morphologyEx(bin,bin,cv.MORPH_CLOSE,kernel);

    // ‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û‡∏´‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•
    canvas.width=bin.cols; canvas.height=bin.rows;
    cv.imshow(canvas,bin);

    // ‚úÖ OCR ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç
    const {data}=await Tesseract.recognize(
      canvas,'eng',
      {logger:m=>console.log(m),
       tessedit_char_whitelist:'0123456789 ',
       tessedit_pageseg_mode:7}
    );

    const txt=data.text.replace(/\s+/g,'');
    const m=txt.match(/\d{13}/);
    if(m){
      const cid=m[0];
      const ok=validateThaiID(cid);
      const first=cid.charAt(0);
      let type='‡πÄ‡∏•‡∏Ç‡∏õ‡∏£‡∏∞‡∏à‡∏≥‡∏ï‡∏±‡∏ß‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏ä‡∏ô (‡∏™‡∏±‡∏ç‡∏ä‡∏≤‡∏ï‡∏¥‡πÑ‡∏ó‡∏¢)';
      if(['0','6','7','8','9'].includes(first))
        type='‡πÄ‡∏•‡∏Ç‡∏ö‡∏∏‡∏Ñ‡∏Ñ‡∏•‡∏ï‡πà‡∏≤‡∏á‡∏î‡πâ‡∏≤‡∏ß / ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏±‡∏ç‡∏ä‡∏≤‡∏ï‡∏¥‡πÑ‡∏ó‡∏¢';
      output.textContent= ok ?
        `‚úÖ ${type} ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏≤‡∏° checksum: ${cid} (‡∏°‡∏∏‡∏°‡πÄ‡∏≠‡∏µ‡∏¢‡∏á ${angle.toFixed(2)}¬∞)`:
        `‚ö†Ô∏è ‡∏û‡∏ö‡πÄ‡∏•‡∏Ç ${cid} ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏ú‡πà‡∏≤‡∏ô checksum (‡∏°‡∏∏‡∏° ${angle.toFixed(2)}¬∞)`;
    }else{
      // ‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÄ‡∏•‡∏Ç 13 ‡∏´‡∏•‡∏±‡∏Å ‚Üí ‡∏•‡∏≠‡∏á‡∏´‡∏°‡∏∏‡∏ô‡∏†‡∏≤‡∏û‡∏≠‡∏µ‡∏Å 180¬∞ ‡πÅ‡∏•‡πâ‡∏ß OCR ‡∏ã‡πâ‡∏≥
        console.log("No 13-digit found, try rotate 180¬∞ and OCR again...");
        let temp = new cv.Mat();
        cv.rotate(rotated, temp, cv.ROTATE_180);

        // ‡πÅ‡∏õ‡∏•‡∏á‡∏†‡∏≤‡∏û‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô gray
        let g2 = new cv.Mat();
        cv.cvtColor(temp, g2, cv.COLOR_RGBA2GRAY, 0);

        // Crop ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏™‡πà‡∏ß‡∏ô‡∏ö‡∏ô‡∏Ç‡∏≠‡∏á‡∏†‡∏≤‡∏û‡πÉ‡∏´‡∏°‡πà
        const h2 = Math.floor(g2.rows * 0.65);
        const roi2 = new cv.Rect(0, 0, g2.cols, h2);
        let top2 = g2.roi(roi2);

        // Threshold + morphology
        let bin2 = new cv.Mat();
        cv.adaptiveThreshold(top2, bin2, 255,
            cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 41, 10);
        let kernel2 = cv.Mat.ones(2, 2, cv.CV_8U);
        cv.morphologyEx(bin2, bin2, cv.MORPH_CLOSE, kernel2);

        // ‚úÖ ‡∏ï‡πâ‡∏≠‡∏á‡∏ß‡∏≤‡∏î bin2 ‡∏•‡∏á canvas ‡∏Å‡πà‡∏≠‡∏ô OCR
        canvas.width = bin2.cols;
        canvas.height = bin2.rows;
        cv.imshow(canvas, bin2);

        // üëÅÔ∏è OCR ‡∏ã‡πâ‡∏≥‡∏≠‡∏µ‡∏Å‡∏£‡∏≠‡∏ö
        const { data: data2 } = await Tesseract.recognize(
            canvas,
            'eng',
            {
                logger: m => console.log(m),
                tessedit_char_whitelist: '0123456789 ',
                tessedit_pageseg_mode: 7
            }
        );

        const txt2 = data2.text.replace(/\s+/g, '');
        const m2 = txt2.match(/\d{13}/);

        if (m2) {
            const cid2 = m2[0];
            const ok2 = validateThaiID(cid2);
            const first2 = cid2.charAt(0);
            let type2 = '‡πÄ‡∏•‡∏Ç‡∏õ‡∏£‡∏∞‡∏à‡∏≥‡∏ï‡∏±‡∏ß‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏ä‡∏ô (‡∏™‡∏±‡∏ç‡∏ä‡∏≤‡∏ï‡∏¥‡πÑ‡∏ó‡∏¢)';
            if(['0','6','7','8','9'].includes(first2))
            type2='‡πÄ‡∏•‡∏Ç‡∏ö‡∏∏‡∏Ñ‡∏Ñ‡∏•‡∏ï‡πà‡∏≤‡∏á‡∏î‡πâ‡∏≤‡∏ß / ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏±‡∏ç‡∏ä‡∏≤‡∏ï‡∏¥‡πÑ‡∏ó‡∏¢';
            output.textContent = ok2
            ? `‚úÖ ${type2} ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏≤‡∏° checksum: ${cid2} (‡∏´‡∏°‡∏∏‡∏ô 180¬∞ ‡πÅ‡∏•‡πâ‡∏ß‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏î‡πâ)`
            : `‚ö†Ô∏è ‡∏û‡∏ö‡πÄ‡∏•‡∏Ç ${cid2} ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏ú‡πà‡∏≤‡∏ô checksum (‡∏´‡∏°‡∏∏‡∏ô 180¬∞ ‡πÅ‡∏•‡πâ‡∏ß‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏î‡πâ)`;
        } else {
            output.textContent = `‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÄ‡∏•‡∏Ç 13 ‡∏´‡∏•‡∏±‡∏Å ‡πÅ‡∏°‡πâ‡∏´‡∏°‡∏∏‡∏ô 180¬∞ ‡πÅ‡∏•‡πâ‡∏ß`;
        }

        // cleanup ‡∏£‡∏≠‡∏ö‡∏™‡∏≠‡∏á
        temp.delete(); g2.delete(); top2.delete(); bin2.delete(); kernel2.delete();
    }

    // ‡∏•‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥
    src.delete(); rotated.delete(); gray.delete(); deskewed.delete();
    top.delete(); bin.delete(); kernel.delete();
  };
});
</script>
</body>
</html>
