<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CID OCR (Top Zone + Multi-Resolution Skip Rotation)</title>
<script src="public/js/opencv.js"></script>
<script src="public/js/tesseract.min.js"></script>
<style>
  body { font-family: sans-serif; }
  canvas { margin: 5px; border: 1px solid #ccc; max-width: 45%; height: auto; }
  #canvases { display: flex; flex-wrap: wrap; justify-content: start; align-items: start; }
  .label { text-align: center; font-size: 14px; margin: 4px 0; }
</style>
</head>
<body>
<h3>‡∏≠‡πà‡∏≤‡∏ô‡πÄ‡∏•‡∏Ç‡∏ö‡∏±‡∏ï‡∏£‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏ä‡∏ô (Top Zone Priority + Multi-Resolution Skip Rotation)</h3>
<input type="file" id="fileInput" accept="image/*"><br>
<pre id="output"></pre>
<div id="canvases">
  <div>
    <canvas id="cvCanvas1"></canvas>
    <div class="label">‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö</div>
  </div>
  <div>
    <canvas id="cvCanvas2"></canvas>
    <div class="label">‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ OCR</div>
  </div>
</div>

<script>
const fileInput = document.getElementById("fileInput");
const output = document.getElementById("output");
const c1 = document.getElementById("cvCanvas1");
const c2 = document.getElementById("cvCanvas2");

// ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à checksum
function validateThaiID(id){
  if(!/^\d{13}$/.test(id)) return false;
  const d = id.split('').map(Number);
  let s=0; for(let i=0;i<12;i++) s+=d[i]*(13-i);
  return (11-(s%11))%10===d[12];
}
function autoFixThaiIDByChecksum(id){
  if(!/^\d{13}$/.test(id)) return null;
  if(validateThaiID(id)) return id;
  const arr=id.split('').map(n=>+n);
  for(let i=0;i<13;i++){
    const orig=arr[i];
    for(let d=0;d<=9;d++){
      if(d===orig) continue;
      arr[i]=d;
      const cand=arr.join('');
      if(validateThaiID(cand)) return cand;
    }
    arr[i]=orig;
  }
  return null;
}

// üß† ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÅ‡∏™‡∏á‡∏†‡∏≤‡∏û
function autoContrastLevel(grayMat){
  const meanScalar = cv.mean(grayMat);
  const brightness = meanScalar[0];
  let claheClip = 1.5, sharpWeight = 1.2, blurWeight = -0.2, normMin = 30, normMax = 230;
  if (brightness < 80) { claheClip = 3.0; sharpWeight = 1.4; blurWeight = -0.4; normMin = 20; normMax = 250; }
  else if (brightness > 150) { claheClip = 1.0; sharpWeight = 1.1; blurWeight = -0.1; normMin = 40; normMax = 210; }
  return { claheClip, sharpWeight, blurWeight, normMin, normMax, brightness };
}

// üîç ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô OCR (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö full ‡∏´‡∏£‡∏∑‡∏≠ zone)
async function runOCR(mat, maxW, angle, label="full"){
  const temp = document.createElement("canvas");
  temp.width = mat.cols; temp.height = mat.rows;
  cv.imshow(temp, mat);
  await new Promise(r=>setTimeout(r, 20));

  let cidResult = null;
  try {
    const { data } = await Tesseract.recognize(temp, 'eng', {
      tessedit_char_whitelist: '0123456789',
      tessedit_pageseg_mode: 6
    });
    const txt = data.text.replace(/\s+/g, '');
    const m = txt.match(/\d{13}/);
    if (m) {
      let cid = m[0];
      if (!validateThaiID(cid)) {
        const fixed = autoFixThaiIDByChecksum(cid);
        if (fixed) cid = fixed;
      }
      if (validateThaiID(cid)) cidResult = cid;
    }
    return { cid: cidResult, raw: data.text, zone: label };
  } catch (e) {
    console.error(e);
    return { cid: null, raw: "error", zone: label };
  }
}

// üß© ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏†‡∏≤‡∏û (Top Zone ‡∏Å‡πà‡∏≠‡∏ô Full)
async function processImage(mat, angle, maxW){
  let gray = new cv.Mat();
  cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY);
  const { claheClip, sharpWeight, blurWeight, normMin, normMax, brightness } = autoContrastLevel(gray);

  const clahe = new cv.CLAHE(claheClip, new cv.Size(8, 8));
  const cl = new cv.Mat();
  clahe.apply(gray, cl);

  const blur = new cv.Mat();
  cv.GaussianBlur(cl, blur, new cv.Size(0, 0), 1.0);
  const sharp = new cv.Mat();
  cv.addWeighted(cl, sharpWeight, blur, blurWeight, 0, sharp);
  cv.normalize(sharp, sharp, normMin, normMax, cv.NORM_MINMAX);

  const bin = new cv.Mat();
  cv.adaptiveThreshold(sharp, bin, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C,
                       cv.THRESH_BINARY, 35, 10);

  const up = new cv.Mat();
  cv.resize(bin, up, new cv.Size(0,0), 1.5, 1.5, cv.INTER_CUBIC);
  c2.width = up.cols; c2.height = up.rows;
  cv.imshow(c2, up);

  // ‚úÖ Step 1: OCR ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÇ‡∏ã‡∏ô‡∏ö‡∏ô‡∏™‡∏∏‡∏î (‡πÄ‡∏ä‡πà‡∏ô 0-40% ‡∏Ç‡∏≠‡∏á‡∏†‡∏≤‡∏û)
  const zoneHeight = Math.floor(up.rows * 0.4);
  const zoneRect = new cv.Rect(0, 0, up.cols, zoneHeight);
  const zoneMat = up.roi(zoneRect);

  let res = await runOCR(zoneMat, maxW, angle, "top-zone");
  output.textContent += `üîπ Top-Zone OCR (0-40%) Brightness=${brightness.toFixed(1)} | CID=${res.cid || "‡πÑ‡∏°‡πà‡∏û‡∏ö"}\n`;
  zoneMat.delete();

  if(res.cid) {
    // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏à‡∏≠‡πÉ‡∏ô zone ‚Üí ‡∏Ç‡πâ‡∏≤‡∏° OCR ‡∏ó‡∏±‡πâ‡∏á‡∏†‡∏≤‡∏û
    gray.delete(); clahe.delete(); cl.delete(); blur.delete(); sharp.delete(); bin.delete(); up.delete();
    return { ...res, maxW, angle, brightness };
  }

  // ‚úÖ Step 2: OCR ‡∏ó‡∏±‡πâ‡∏á‡∏†‡∏≤‡∏û (‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠)
  res = await runOCR(up, maxW, angle, "full");
  output.textContent += `üîπ Full Image OCR Brightness=${brightness.toFixed(1)} | CID=${res.cid || "‡πÑ‡∏°‡πà‡∏û‡∏ö"}\n`;

  gray.delete(); clahe.delete(); cl.delete(); blur.delete(); sharp.delete(); bin.delete(); up.delete();
  return { ...res, maxW, angle, brightness };
}

// üß† ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
fileInput.addEventListener("change", async e=>{
  output.textContent="‚è≥ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏≠‡πà‡∏≤‡∏ô...";
  const f=e.target.files[0];
  if(!f) return;
  const img=new Image();
  img.src=URL.createObjectURL(f);
  img.onload=async()=>{
    const resolutions = [800, 960, 1280];
    const aspect = img.width / img.height;
    const angles = (aspect>1.2)? [0] : [0,270,180,90];
    let results = [];

    for (const maxW of resolutions) {
      output.textContent += `\n=== üîç ‡∏ó‡∏î‡∏•‡∏≠‡∏á‡∏Ç‡∏ô‡∏≤‡∏î maxW = ${maxW} ===\n`;
      const scale = img.width > maxW ? maxW / img.width : 1;
      c1.width = img.width * scale; c1.height = img.height * scale;
      const ctx = c1.getContext("2d");
      ctx.drawImage(img, 0, 0, c1.width, c1.height);
      let src = cv.imread(c1);

      let foundForThisRes = false;

      for (let a of angles) {
        if(foundForThisRes) break;

        let rot=new cv.Mat();
        switch(a){
          case 0: rot=src.clone();break;
          case 90: cv.rotate(src,rot,cv.ROTATE_90_CLOCKWISE);break;
          case 180: cv.rotate(src,rot,cv.ROTATE_180);break;
          case 270: cv.rotate(src,rot,cv.ROTATE_90_COUNTERCLOCKWISE);break;
        }

        const res = await processImage(rot,a,maxW);
        rot.delete();

        results.push(res);
        if(res.cid && res.cid.length===13){
          foundForThisRes = true;
          output.textContent += `‚úÖ ‡∏û‡∏ö‡πÄ‡∏•‡∏Ç‡∏Ñ‡∏£‡∏ö 13 ‡∏´‡∏•‡∏±‡∏Å‡∏ó‡∏µ‡πà maxW=${maxW} (‡∏°‡∏∏‡∏° ${res.angle}¬∞ ‡∏à‡∏≤‡∏Å ${res.zone}) ‚Üí ‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏õ‡∏Ç‡∏ô‡∏≤‡∏î‡∏ñ‡∏±‡∏î‡πÑ‡∏õ\n`;
        }
      }

      src.delete();
    }

    const found = results.filter(r=>r.cid);
    if(found.length){
      output.textContent += `\n‚úÖ ‡∏û‡∏ö‡πÄ‡∏•‡∏Ç ${found[0].cid} (‡∏à‡∏≤‡∏Å maxW=${found[0].maxW}, zone=${found[0].zone}, ‡∏°‡∏∏‡∏° ${found[0].angle}¬∞)\n`;
    }else{
      output.textContent += `\n‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÄ‡∏•‡∏Ç‡∏ö‡∏±‡∏ï‡∏£‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡∏°‡∏∏‡∏°`;
    }
  };
});
</script>
</body>
</html>
