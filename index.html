<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CID OCR (Top Zone + Multi-Resolution Skip Rotation)</title>
<script src="public/js/opencv.js"></script>
<script src="public/js/tesseract.min.js"></script>
<style>
  body { font-family: sans-serif; }
  canvas { margin: 5px; border: 1px solid #ccc; max-width: 45%; height: auto; }
  #canvases { display: flex; flex-wrap: wrap; justify-content: start; align-items: start; }
  .label { text-align: center; font-size: 14px; margin: 4px 0; }
  #btns { margin:10px 0; }
  button { margin-right:8px; padding:6px 12px; background:#007bff; color:#fff; border:none; border-radius:5px; cursor:pointer; }
  button:hover { background:#0056b3; }
</style>
</head>
<body>
<h3>‡∏≠‡πà‡∏≤‡∏ô‡πÄ‡∏•‡∏Ç‡∏ö‡∏±‡∏ï‡∏£‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏ä‡∏ô (Top Zone Priority + Multi-Resolution Skip Rotation)</h3>

<input type="file" id="fileInput" accept="image/*"><br>

<div id="btns">
  <button id="rotateLeft">‚Ü©Ô∏è ‡∏´‡∏°‡∏∏‡∏ô‡∏ã‡πâ‡∏≤‡∏¢</button>
  <button id="rotateRight">‚Ü™Ô∏è ‡∏´‡∏°‡∏∏‡∏ô‡∏Ç‡∏ß‡∏≤</button>
  <button id="startOCR">üîç ‡πÄ‡∏£‡∏¥‡πà‡∏° OCR</button>
</div>

<pre id="output"></pre>
<div id="canvases">
  <div>
    <canvas id="cvCanvas1"></canvas>
    <div class="label">‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö</div>
  </div>
  <div>
    <canvas id="cvCanvas2"></canvas>
    <div class="label">‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ OCR</div>
  </div>
</div>

<script>
const fileInput = document.getElementById("fileInput");
const output = document.getElementById("output");
const c1 = document.getElementById("cvCanvas1");
const c2 = document.getElementById("cvCanvas2");
const startBtn = document.getElementById("startOCR");
let srcMat = null;

// ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à checksum
function validateThaiID(id){
  if(!/^\d{13}$/.test(id)) return false;
  const d = id.split('').map(Number);
  let s=0; for(let i=0;i<12;i++) s+=d[i]*(13-i);
  return (11-(s%11))%10===d[12];
}
function autoFixThaiIDByChecksum(id){
  if(!/^\d{13}$/.test(id)) return null;
  if(validateThaiID(id)) return id;
  const arr=id.split('').map(n=>+n);
  for(let i=0;i<13;i++){
    const orig=arr[i];
    for(let d=0;d<=9;d++){
      if(d===orig) continue;
      arr[i]=d;
      const cand=arr.join('');
      if(validateThaiID(cand)) return cand;
    }
    arr[i]=orig;
  }
  return null;
}

// üß† ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÅ‡∏™‡∏á‡∏†‡∏≤‡∏û
function autoContrastLevel(grayMat){
  const meanScalar = cv.mean(grayMat);
  const brightness = meanScalar[0];
  let claheClip = 1.5, sharpWeight = 1.2, blurWeight = -0.2, normMin = 30, normMax = 230;
  if (brightness < 80) { claheClip = 3.0; sharpWeight = 1.4; blurWeight = -0.4; normMin = 20; normMax = 250; }
  else if (brightness > 150) { claheClip = 1.0; sharpWeight = 1.1; blurWeight = -0.1; normMin = 40; normMax = 210; }
  return { claheClip, sharpWeight, blurWeight, normMin, normMax, brightness };
}

// üîç OCR Function
async function runOCR(mat, maxW, angle, label="full"){
  const temp = document.createElement("canvas");
  temp.width = mat.cols; temp.height = mat.rows;
  cv.imshow(temp, mat);
  await new Promise(r=>setTimeout(r, 20));

  let cidResult = null;
  try {
    const { data } = await Tesseract.recognize(temp, 'eng', {
      tessedit_char_whitelist: '0123456789',
      tessedit_pageseg_mode: 6
    });
    const txt = data.text.replace(/\s+/g, '');
    const m = txt.match(/\d{13}/);
    if (m) {
      let cid = m[0];
      if (!validateThaiID(cid)) {
        const fixed = autoFixThaiIDByChecksum(cid);
        if (fixed) cid = fixed;
      }
      if (validateThaiID(cid)) cidResult = cid;
    }
    return { cid: cidResult, raw: data.text, zone: label };
  } catch (e) {
    console.error(e);
    return { cid: null, raw: "error", zone: label };
  }
}

// üß© Process per rotation
async function processImage(mat, angle, maxW){
  let gray = new cv.Mat();
  cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY);
  const { claheClip, sharpWeight, blurWeight, normMin, normMax, brightness } = autoContrastLevel(gray);

  const clahe = new cv.CLAHE(claheClip, new cv.Size(8, 8));
  const cl = new cv.Mat();
  clahe.apply(gray, cl);

  const blur = new cv.Mat();
  cv.GaussianBlur(cl, blur, new cv.Size(0, 0), 1.0);
  const sharp = new cv.Mat();
  cv.addWeighted(cl, sharpWeight, blur, blurWeight, 0, sharp);
  cv.normalize(sharp, sharp, normMin, normMax, cv.NORM_MINMAX);

  const bin = new cv.Mat();
  cv.adaptiveThreshold(sharp, bin, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C,
                       cv.THRESH_BINARY, 35, 10);

  const up = new cv.Mat();
  cv.resize(bin, up, new cv.Size(0,0), 1.5, 1.5, cv.INTER_CUBIC);
  c2.width = up.cols; c2.height = up.rows;
  cv.imshow(c2, up);

  // Step 1: Top zone first
  const zoneHeight = Math.floor(up.rows * 0.4);
  const zoneRect = new cv.Rect(0, 0, up.cols, zoneHeight);
  const zoneMat = up.roi(zoneRect);

  let res = await runOCR(zoneMat, maxW, angle, "top-zone");
  output.textContent += `üîπ Top-Zone OCR (0-40%) Brightness=${brightness.toFixed(1)} | CID=${res.cid || "‡πÑ‡∏°‡πà‡∏û‡∏ö"}\n`;
  zoneMat.delete();

  if(res.cid) {
    gray.delete(); clahe.delete(); cl.delete(); blur.delete(); sharp.delete(); bin.delete(); up.delete();
    return { ...res, maxW, angle, brightness };
  }

  // Step 2: Full image fallback
  res = await runOCR(up, maxW, angle, "full");
  output.textContent += `üîπ Full Image OCR Brightness=${brightness.toFixed(1)} | CID=${res.cid || "‡πÑ‡∏°‡πà‡∏û‡∏ö"}\n`;

  gray.delete(); clahe.delete(); cl.delete(); blur.delete(); sharp.delete(); bin.delete(); up.delete();
  return { ...res, maxW, angle, brightness };
}

// ‚úÖ ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå ‚Üí ‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û‡πÄ‡∏â‡∏¢ ‡πÜ
fileInput.addEventListener("change", e=>{
  const f = e.target.files[0];
  if(!f) return;

  // üß© ‡∏ï‡∏£‡∏ß‡∏à‡∏Ç‡∏ô‡∏≤‡∏î‡πÑ‡∏ü‡∏•‡πå‡∏Å‡πà‡∏≠‡∏ô‡πÇ‡∏´‡∏•‡∏î
  const fileSizeMB = f.size / 1024 / 1024;
  const img = new Image();
  img.src = URL.createObjectURL(f);

  img.onload = ()=>{
    // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏´‡∏ç‡πà‡∏Å‡∏ß‡πà‡∏≤ 2MB ‚Üí ‡∏à‡∏≥‡∏Å‡∏±‡∏î maxW = 1280
    // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏•‡πá‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ö 2MB ‚Üí ‡πÉ‡∏ä‡πâ‡∏Ç‡∏ô‡∏≤‡∏î‡∏à‡∏£‡∏¥‡∏á (‡πÑ‡∏°‡πà‡∏¢‡πà‡∏≠)
    let maxW = img.width;
    if (fileSizeMB > 2) {
      maxW = 1280;
      output.textContent = `‚ö†Ô∏è ‡∏Ç‡∏ô‡∏≤‡∏î‡πÑ‡∏ü‡∏•‡πå ${fileSizeMB.toFixed(2)} MB > 2MB ‚Üí ‡∏¢‡πà‡∏≠‡∏†‡∏≤‡∏û‡πÄ‡∏´‡∏•‡∏∑‡∏≠ maxWidth = 1280\n`;
    } else {
      output.textContent = `üì¶ ‡∏Ç‡∏ô‡∏≤‡∏î‡πÑ‡∏ü‡∏•‡πå ${fileSizeMB.toFixed(2)} MB ‚â§ 2MB ‚Üí ‡πÉ‡∏ä‡πâ‡∏Ç‡∏ô‡∏≤‡∏î‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö\n`;
    }

    const scale = img.width > maxW ? maxW / img.width : 1;
    c1.width = img.width * scale;
    c1.height = img.height * scale;
    const ctx = c1.getContext("2d");
    ctx.drawImage(img, 0, 0, c1.width, c1.height);

    if(srcMat) srcMat.delete();
    srcMat = cv.imread(c1);

    output.textContent += "üì∏ ‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß ‚Äî ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏´‡∏°‡∏∏‡∏ô‡πÑ‡∏î‡πâ ‡∏à‡∏≤‡∏Å‡∏ô‡∏±‡πâ‡∏ô‡∏Å‡∏î '‡πÄ‡∏£‡∏¥‡πà‡∏° OCR'";
  };
});


// ‚úÖ ‡∏õ‡∏∏‡πà‡∏°‡∏´‡∏°‡∏∏‡∏ô
document.getElementById("rotateLeft").onclick = ()=>rotateCanvas(-90);
document.getElementById("rotateRight").onclick = ()=>rotateCanvas(90);

function rotateCanvas(deg){
  if(!srcMat){ alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏π‡∏õ‡∏Å‡πà‡∏≠‡∏ô"); return; }
  const rot = new cv.Mat();
  if(deg===90) cv.rotate(srcMat,rot,cv.ROTATE_90_CLOCKWISE);
  else if(deg===-90) cv.rotate(srcMat,rot,cv.ROTATE_90_COUNTERCLOCKWISE);
  srcMat.delete();
  srcMat=rot;
  cv.imshow(c1,srcMat);
  output.textContent=`‡∏´‡∏°‡∏∏‡∏ô‡∏†‡∏≤‡∏û ${deg>0?"‡∏Ç‡∏ß‡∏≤":"‡∏ã‡πâ‡∏≤‡∏¢"} 90¬∞`;
}

// ‚úÖ ‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏£‡∏¥‡πà‡∏° OCR
startBtn.addEventListener("click", runMainOCR);

async function runMainOCR(){
  if(!srcMat){ output.textContent="‚ùå ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏†‡∏≤‡∏û"; return; }
  output.textContent="‚è≥ ‡πÄ‡∏£‡∏¥‡πà‡∏° OCR ...";

  const resolutions = [800, 960, 1280];
  const aspect = srcMat.cols / srcMat.rows;
  const angles = (aspect>1.2)? [0] : [0,270,180,90];
  let results = [];

  for (const maxW of resolutions) {
    output.textContent += `\n=== üîç ‡∏ó‡∏î‡∏•‡∏≠‡∏á‡∏Ç‡∏ô‡∏≤‡∏î maxW = ${maxW} ===\n`;
    const scale = srcMat.cols > maxW ? maxW / srcMat.cols : 1;
    const resized = new cv.Mat();
    cv.resize(srcMat, resized, new cv.Size(0,0), scale, scale, cv.INTER_AREA);

    let foundForThisRes = false;

    for (let a of angles) {
      if(foundForThisRes) break;

      let rot = new cv.Mat();
      switch(a){
        case 0: rot=resized.clone();break;
        case 90: cv.rotate(resized,rot,cv.ROTATE_90_CLOCKWISE);break;
        case 180: cv.rotate(resized,rot,cv.ROTATE_180);break;
        case 270: cv.rotate(resized,rot,cv.ROTATE_90_COUNTERCLOCKWISE);break;
      }

      const res = await processImage(rot,a,maxW);
      rot.delete();
      results.push(res);

      if(res.cid && res.cid.length===13){
        foundForThisRes = true;
        output.textContent += `‚úÖ ‡∏û‡∏ö‡πÄ‡∏•‡∏Ç‡∏Ñ‡∏£‡∏ö 13 ‡∏´‡∏•‡∏±‡∏Å‡∏ó‡∏µ‡πà maxW=${maxW} (‡∏°‡∏∏‡∏° ${res.angle}¬∞ ‡∏à‡∏≤‡∏Å ${res.zone}) ‚Üí ‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏õ‡∏Ç‡∏ô‡∏≤‡∏î‡∏ñ‡∏±‡∏î‡πÑ‡∏õ\n`;
      }
    }
    resized.delete();
  }

  const found = results.filter(r=>r.cid);
  if(found.length){
    output.textContent += `\n‚úÖ ‡∏û‡∏ö‡πÄ‡∏•‡∏Ç ${found[0].cid} (‡∏à‡∏≤‡∏Å maxW=${found[0].maxW}, zone=${found[0].zone}, ‡∏°‡∏∏‡∏° ${found[0].angle}¬∞)\n`;
  }else{
    output.textContent += `\n‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÄ‡∏•‡∏Ç‡∏ö‡∏±‡∏ï‡∏£‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡∏°‡∏∏‡∏°`;
  }
}
</script>
</body>
</html>
